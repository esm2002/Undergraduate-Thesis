`timescale 1ns/1ps
module mac #(
parameter WIDTH = 8,          // Bitwidth of inputs                      //32(FP32)
parameter K  = 1, 
parameter WK = $clog2(K),   
parameter EXP = 4,        // Number of exponent bits                      //8(FP32)
parameter MTS = 3,       // Number of mantissa bits                      //23(FP32)
parameter BIAS = 7,     // bias = 2^(EXP-1) - 1                         //127(FP32)
parameter EXP_MAX = 14,  // exp_max = 2^EXP - 2                          //254(FP32)
parameter clog2_MAXMIN = 17, // max/min = 2^(exp_max-1)*(2^(mts+1)-1)    //277(FP32)
parameter WIDTH_A = WK + 2*clog2_MAXMIN + 2,
parameter WZC = $clog2(WIDTH_A))(
input clk,
input rstn,
input vld_i, 
input signed [WIDTH-1:0] win, 
input signed [WIDTH-1:0] din, 
output[WIDTH-1:0] acc_o
//output  vld_o
);

reg [EXP-1:0] exp_w;
reg [EXP-1:0] exp_d;
reg [MTS-1:0] mts_w_tmp;
reg [MTS-1:0] mts_d_tmp;

wire zero_w;
wire zero_d;
reg [MTS:0] mts_w;
reg [MTS:0] mts_d;
(* use_dsp = "yes" *) reg [EXP:0] exp_fp_tmp;

reg sign_fp;
(* use_dsp = "yes" *) reg [2*MTS+1:0] mts_fp;
(* use_dsp = "yes" *) reg [EXP:0] exp_fp;

wire signed [2*MTS+2:0] mts_fx; 
wire signed [WIDTH_A-1:0] mts_fxs;
(* use_dsp = "yes" *) reg signed [WIDTH_A-1:0] acc; // bit configuration: WIDTH_A = 1 + 2BIAS + (3 + 2MTS) + (2BIAS - 2)

wire [WIDTH_A-1:0] acc_mag;
wire [WZC-1:0] zc;
wire vld;

wire guard_bit;
wire round_bit;
wire sticky_bit;
wire round_val;

reg signed sign_r;
reg [WIDTH_A-1:0] mts_tmp;
(* use_dsp = "yes" *) reg [MTS+1:0] mts_r;
(* use_dsp = "yes" *) reg [EXP+1:0] exp_r;
reg [WIDTH-1:0] acc_rc;

//reg [K:0] vld_d;

//-------------------------------------------------
// Extraction & Subnormal Detection
//-------------------------------------------------

always @(posedge clk, negedge rstn) begin
    if (~rstn) begin
        sign_fp <= 0;
        exp_w <= 0;
        exp_d <= 0;
        mts_w_tmp <= 0;
        mts_d_tmp <= 0;
    end
    else if (vld_i) begin
        sign_fp <= win[WIDTH-1] ^ din[WIDTH-1];
        exp_w <= win[EXP + MTS - 1: MTS];
        exp_d <= din[EXP + MTS - 1: MTS];
        mts_w_tmp <= win[MTS - 1: 0];
        mts_d_tmp <= din[MTS - 1: 0];
    end
end

assign zero_w = |exp_w; // 0 for zero 
assign zero_d = |exp_d; // 0 for zero 

always @(posedge clk, negedge rstn) begin
    if (~rstn) begin
        //zero_w <= 0; // 0 for zero 
        //zero_d <= 0; // 0 for zero 
        mts_w <= 0; // 0.f for subnormal
        mts_d <= 0; // 0.f for subnormal
        exp_fp_tmp <= 0;
    end
    else begin
        //zero_w <= |exp_w; // 0 for zero 
        //zero_d <= |exp_d; // 0 for zero 
        mts_w <= {zero_w, mts_w_tmp}; // 0.f for subnormal
        mts_d <= {zero_d, mts_d_tmp}; // 0.f for subnormal
        exp_fp_tmp <= exp_w + exp_d;
    end
end

//-------------------------------------------------
// Multiplication
//-------------------------------------------------

always @(posedge clk, negedge rstn) begin
    if (~rstn) begin
         mts_fp <= 0;
         exp_fp <= 0;
    end
    else begin
        mts_fp <= mts_w * mts_d;
        exp_fp <= exp_fp_tmp + !zero_w + !zero_d + 1; 
    end // (1)biased_ex1!=0, biased_ex2!=0 : exp_fp = biased_ex1 + biased_ex2 + 1 = ex1 + ex2 + 2BIAS + 1
end     // (2)biased_ex1=0, biased_ex2!=0 : exp_fp = biased_ex1 + biased_ex2 + ~zero_1 + 1 = ex2 + BIAS + 2
        // (3)biased_ex1=0, biased_ex2=0 : exp_fp = biased_ex1 + biased_ex2 + 1 = ~zero_1 + ~zero_2 + 1 = 3


//-------------------------------------------------
// Accumulation
//-------------------------------------------------

//reg [WK-1:0] counter;

assign mts_fx = sign_fp ? ~({1'b0, mts_fp}) + 1 : {1'b0, mts_fp};
assign mts_fxs = mts_fx << (exp_fp - 3);
// (1)biased_ex1!=0, biased_ex2!=0 : exp_fp - 3 = ex1 + ex2 + 2BIAS - 2
// (2)biased_ex1=0, biased_ex2!=0 : exp_fp - 3 = ex2 + BIAS - 1
// (3)biased_ex1=0, biased_ex2=0 : exp_fp - 3 = 3 - 3 = 0

always @(posedge clk, negedge rstn) begin
    if (~rstn)
        acc <= 0;
    else
        acc <= acc + mts_fxs; // bit configuration: WIDTH_A = 1 + 2BIAS + (3 + 2MTS) + (2BIAS - 2) 
end

//-------------------------------------------------
// Converting to Floating Point: 2's Comp & Normalization & Rounding
//-------------------------------------------------

always @(posedge clk, negedge rstn) begin
    if (~rstn) begin
        sign_r <= 0;
    end
    else begin
        sign_r <= acc[WIDTH_A-1];
    end
end

assign acc_mag = sign_r ? ~(acc) + 1 : acc;

LZD #(.in_s(WIDTH_A), .out_s(WZC)) u_lzd(.in(acc_mag), .out(zc), .vld(vld));
 
function sticky(input [WIDTH_A-1:0] acc_mag);
    integer i;
    begin
        sticky = 0;
        for (i = 0; i <= WIDTH_A - 1 - zc - MTS - 3; i = i + 1)
            sticky = sticky | acc_mag[i];
    end
endfunction 
 
assign guard_bit = acc_mag[WIDTH_A-1-zc-MTS-1];
assign round_bit = acc_mag[WIDTH_A-1-zc-MTS-2];
assign sticky_bit = sticky(acc_mag); // |acc_mag[WIDTH_A-1-zc-MTS-3:0]
assign round_val = guard_bit & (round_bit | sticky_bit); 

always @(posedge clk, negedge rstn) begin
    if (~rstn) begin
        exp_r <= 0;
        mts_tmp <= 0;
        
        mts_r <= 0;
    end    
    else begin
        exp_r <= EXP_MAX + BIAS + 3 - zc;
        mts_tmp <= acc_mag[WIDTH_A-1:0] << zc;
        
        mts_r <= mts_tmp[(WIDTH_A-1)-:MTS+1] + round_val; // 1.f
    end
end

//-------------------------------------------------
// Converting to Floating Point: Clip & Output
//-------------------------------------------------

always @(posedge clk, negedge rstn) begin
    if (~rstn)
        acc_rc <= 0;
    else if ((~exp_r[EXP+1] & exp_r[EXP]) | (exp_r == EXP_MAX + 1)) //overflow
        acc_rc <= {sign_r, 1'b0, {(EXP-1){1'b1}}, {MTS{1'b1}}}; //set max mag value 
    else if (exp_r[EXP+1]) //underflow
        acc_rc <= {sign_r, {EXP{1'b0}}, {(MTS-1){1'b0}}, 1'b1};  //set min mag value
    else
        if (mts_r[MTS+1]) //consider a carry by adding round_val 
            if (exp_r == EXP_MAX) //overflow by rounding
                acc_rc <= {sign_r, 1'b0, {(EXP-1){1'b1}}, {MTS{1'b1}}};
            else
                acc_rc <= {sign_r, exp_r[EXP-1:0] + 1, mts_r[MTS:1]};
        else
            acc_rc <= {sign_r, exp_r, mts_r[MTS-1:0]};
end


//always@(posedge clk, negedge rstn) begin
//	if(~rstn) begin
//		vld_d <= 0;
//	end
//	else begin
//		vld_d <= {vld_d[K-1:0], vld_i};
//    end
//end

//assign vld_o = (&vld_d[K:1])&(~vld_d[0]); // ON for 1 clock period
assign acc_o = acc_rc; //consider a carry by adding round_val 

endmodule


