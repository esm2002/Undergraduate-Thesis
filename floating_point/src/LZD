`timescale 1ns/1ps
module LZD #(
parameter in_s = 2*14 + 2*3 + 2, // = 4BIAS + 2MTS + 2
parameter out_s = $clog2(in_s))( // = 6
input [in_s-1:0] in,
output [out_s-1:0] out, 
output vld
);
/*
localparam isn_pow2 = (in_s & (in_s-1)) != 0;
localparam P2 = 1 << out_s;

generate
    if (in_s == 2) begin
        assign out = !in[1] & in[0]; 
        assign vld = |in;
    end
    else if (isn_pow2) begin // not a power of 2
        //wire [out_s-1:0] out_p;
        LZD #(.in_s(P2), .out_s(out_s)) padd(.in(({P2{1'b0}}|in)), .out(out), .vld(vld));
    end
    else begin // a power of 2
        wire [out_s-2:0] out_l, out_h;
        wire vld_l, vld_h;
        LZD #(.in_s(in_s >> 1), .out_s(out_s-1)) low(.in(in[(in_s >> 1)-1:0]), .out(out_l), .vld(vld_l));
        LZD #(.in_s(in_s >> 1), .out_s(out_s-1)) high(.in(in[in_s-1:(in_s >> 1)]), .out(out_h), .vld(vld_h));
        assign out = vld_h ? {1'b0,out_h} : {vld_l,out_l}; 
        assign vld = vld_l | vld_h;
    end 
endgenerate
*/
/////////////////////////////////////////////////
integer i;
reg [out_s-1:0] out_tmp; 
reg vld_tmp;
  always @(*) begin
    out_tmp = {out_s{1'b0}};
    vld_tmp = 1'b0;
    for (i = in_s-1; i >= 0; i = i - 1) begin
      if (!vld_tmp && in[i]) begin
        out_tmp = in_s - i - 1;
        vld_tmp = 1'b1;
      end
    end
  end

assign vld = vld_tmp;
assign out = out_tmp;

endmodule
